#!/usr/bin/env python

import os, sys, argparse
import datetime
import agspy.utils.pretty as pretty
import multiprocessing
import gippy.landsat as landsat
import traceback

if __name__ == "__main__":
    prog = os.path.split(__file__)[1]
    parser0 = argparse.ArgumentParser(prog=prog, formatter_class=argparse.ArgumentDefaultsHelpFormatter,
        description='Landsat Archive Utilities')
    subparser = parser0.add_subparsers(dest='command')

    # Global options
    gparser = argparse.ArgumentParser(add_help=False, 
        formatter_class=argparse.ArgumentDefaultsHelpFormatter)
    gparser.add_argument('pathrow', nargs='*', help='the Landsat pathrow(s)')
    gparser.add_argument('-d', '--dates',help='Range of dates (YYYY-MM-DD,YYYY-MM-DD)')

    # Inventory
    parser = subparser.add_parser('inventory',help='Get Landsat Inventory', parents=[gparser], 
        formatter_class=argparse.ArgumentDefaultsHelpFormatter)
    parser.add_argument('--md',help='Show dates using MM-DD',action='store_true',default=False)
    parser.add_argument('--fn',help='List full filenames instead of dates',action='store_true',default=False)
    parser.add_argument('-p', help='Also list all products available',action='store_true',default=False)

    # Links
    parser = subparser.add_parser('link',help='Link to Landsat Products', parents=[gparser],
        formatter_class=argparse.ArgumentDefaultsHelpFormatter)
    parser.add_argument('-p','--product',help='Limit links to product (e.g., refl)',default="")
    parser.add_argument('--hard',help='Create hard links instead of symbolic links (can only be used on titan)',
        default=False,action='store_true')
    #parser.add_argument('--mnt',help='Create links through /mnt (soft links only)',default=False,action='store_true')

    # Misc
    #parser_info = subparser.add_parser('info',help='Print summary metadata', parents=[gparser])
    #parser_unzip = subparser.add_parser('unzip',help='Unzip Landsat tar file', parents=[gparser])
    parser_archive = subparser.add_parser('archive',help='Move files from this directory to Landsat archive')
    parser_clean = subparser.add_parser('clean',help='Clean archive of all temporary files')
    parser_getmerra = subparser.add_parser('getmerra',help='Get MERRA profile for matching files', parents=[gparser])
    #parser_check = subparser.add_parser('diagnostic',help='Check validity of Landsat tar files', parents=[gparser])

    # General processing options
    pparser = argparse.ArgumentParser(add_help=False,formatter_class=argparse.ArgumentDefaultsHelpFormatter)
    pparser.add_argument('--overviews', help='Add Overviews to output', default=False, action='store_true')
    pparser.add_argument('-v','--verbose', help='Verbosity level', default=0, type=int)
    #pparser.add_argument('--link', help='Create links in current directory to output', default=False, action='store_true')
    #pparser.add_argument('--multi', help='Use multiple processors', default=False, action='store_true')
    pparser.add_argument('--overwrite', help='Overwrite output files if they exist', default=False, action='store_true')
    pparser.add_argument('--suffix', help='Append string to end of filename (before extension)',default='')

    parser = subparser.add_parser('process',help='Process Landsat scenes', parents=[gparser,pparser], 
        formatter_class=argparse.ArgumentDefaultsHelpFormatter)
    #parser.add_argument('-u','--units',help='Units (rad, ref)', default='rad')
    parser.add_argument('--type',help='Data type of output file (Int16,Float32)', default='Int16')
    parser.add_argument('-a', '--atmcorr',action='store_true',help='Atmospheric Correction', default=False)
    parser.add_argument('-p', '--product',nargs='*',help='Output product to create (radi,refl,temp,cind)',default=['radi'])

    parser = subparser.add_parser('alg',help='Run algorithm on scenes', #parents=[gparser,pparser],
        formatter_class=argparse.ArgumentDefaultsHelpFormatter)
    psubparser = parser.add_subparsers(dest='alg')
    # Auto-import list of algorithms in alg module
    algorithms = ['acloud','fmask']
    for alg in algorithms:
        exec('import gippy.algorithms.%s as %s' % (alg,alg))
        exec('%s.add_options(psubparser,[gparser,pparser])' % alg)

    args = parser0.parse_args()

    if args.command == 'inventory':
        if len(args.pathrow) == 0:
            prs = sorted(os.listdir(landsat.rawdir))
        else: prs = args.pathrow
        totalfiles = 0
        for pr in prs:
            fnames = landsat.inventory(pr,args.dates)
            # print the stuff here
            if len(fnames) > 0:
                sys.stdout.write('Data for path/row %s' % pr)
            oldyear = ''
            for pathname in fnames:
                basename = os.path.basename(pathname)
                year = int(basename[9:13])
                doy = int(basename[13:16])
                date = datetime.date(year,1,1) + datetime.timedelta(doy-1)
                sensor = int(basename[2:3])
                if year != oldyear:
                    sys.stdout.write('\n  %s:' % year)
                if sensor == 4:
                    col = 'bright yellow'
                elif sensor == 5:
                    col = 'bright red'
                elif sensor == 7:
                    col = 'bright green'
                elif sensor == 8:
                    col = 'bright blue'
                else: 
                    col = 'white'
                if args.md:
                    d = str(date.month) + '-' + str(date.day)
                elif args.fn:
                    d = '\n  ' + pathname
                else: d = str(doy)
                # List products also?
                sdoy = str(doy)
                if len(sdoy) == 1:
                    sdoy = '00' + sdoy
                elif len(sdoy) == 2:
                    sdoy = '0' + sdoy
                if args.p:
                    import glob
                    # Get listing of products
                    files = landsat.inventory(pr,str(date),products=True)
                    products = {}
                    for f in files:
                        key = os.path.basename(f)[17:18]
                        if key == "A":
                            key = "Atm"
                        else: key = "NoAtm"
                        val = os.path.basename(f)[19:-4]
                        if key in products:
                            products[key] = products[key] + ', ' + val
                        else:
                            products[key] = val
                        products[key].strip(', ')
                    prodstr = ''
                    for k,v in products.iteritems():
                        prodstr = prodstr + ' \t' + k + ' (' + v + ') '
                    d = '\n    ' + d + prodstr
                pretty.writec(' %s ' % d,col)
                oldyear = year
            sys.stdout.write('\n')
            totalfiles = totalfiles + len(fnames)
        if totalfiles > 0:
            pretty.writec(' Landsat4 ', 'bright yellow')
            pretty.writec(' Landsat5 ','bright red')
            pretty.writec(' Landsat7 ','bright green')
            pretty.writec(' Landsat8 ','bright blue')
            sys.stdout.write('\n')
            print '  Total of %i matching data files' % totalfiles
        else:
            print 'No data matching criteria in inventory'

    elif args.command == 'link':
        for pr in args.pathrow:
            landsat.link(pr,args.dates,hard=args.hard,filt=args.product)

    elif args.command == 'process':
        for pr in args.pathrow:
            fnames = landsat.inventory(pr,args.dates)
            print 'Processing %s products for %s files' % (len(args.product), len(fnames))
            landsat.batchprocess(fnames, products=args.product,  atmcorr=args.atmcorr, 
                datatype=args.type, verbose=args.verbose, overwrite=args.overwrite, suffix=args.suffix, overviews=args.overviews)

    elif args.command == 'alg':
        for pr in args.pathrow:
            fnames = landsat.inventory(pr,args.dates)
            print 'Running %s algorithm for %s files' % (args.alg, len(fnames))
            for f in fnames:
                # Atmospheric correction for algorithms??
                try:
                    start = datetime.datetime.now()
                    fout = landsat.outfile(f, product=args.alg, # atmcorr=args.atmcorr)
                        overwrite=args.overwrite, suffix=args.suffix) 
                    img = landsat.read(f,verbose=args.verbose)
                    if args.overviews: img.AddOverviews()
                    eval('%s.process(img,fout,**args.__dict__)' % (args.alg) )
                    print '%s -> %s: processed in %s' % \
                        (os.path.basename(f)[:-12],os.path.basename(fout),datetime.datetime.now() - start)
                except Exception,e:
                    print '%s %s' % (os.path.basename(f)[:16],e)
                    if args.verbose > 1: print traceback.format_exc()
                img = None
                landsat._cleandir(os.path.dirname(f))

    elif args.command == 'archive':
        landsat.archive()

    elif args.command == 'clean':
        landsat.clean()

    elif args.command == 'getmerra':
        from gippy.atmosphere import fetchmerra
        for pr in args.pathrow:
            fnames = landsat.inventory(pr,args.dates)
            print 'Downloading %s merra profiles' % len(fnames)
            for f in fnames:
                start = datetime.datetime.now()
                try:
                    meta = landsat.readmeta(f)
                    merrafname = fetchmerra(meta['datetime'])
                    print '%s: %s' % (os.path.basename(merrafname),datetime.datetime.now()-start)
                except Exception,e:
                    print '%s %s' % (os.path.basename(f)[:16],e) 

    else:
        print 'Command %s not recognized' % cmd

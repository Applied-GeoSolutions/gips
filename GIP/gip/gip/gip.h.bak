#ifndef GIP_H
#define GIP_H

#include <iostream>
#include <sstream>
#include <map>
#include <gdal_priv.h>

namespace gip {
	using std::string;

	//namespace Color { enum Enum{ None, Blue, Green, Red, NIR, SWIR1, SWIR2, LWIR };	}
	enum Color{ None, Blue, Green, Red, NIR, SWIR1, SWIR2, LWIR };
	//!  Colors class to specify series of band colors
	class Colors {
	public:
		//! Default Colors (none set)
		Colors() {}
		//! Set band numbers colors
		Colors(int blue, int green, int red, int nir, int swir1, int swir2, int lwir) {
			SetColor(Color::Blue, blue);
			SetColor(Color::Green, green);
			SetColor(Color::Red, red);
			SetColor(Color::NIR, nir);
			SetColor(Color::SWIR1, swir1);
			SetColor(Color::SWIR2, swir2);
			SetColor(Color::LWIR, lwir);
		}
		//! Set color
		//void SetColor(Color::Enum col, int bandnum) {
        void SetColor(Color col, int bandnum) {
			_ColorsToBandNums[col] = bandnum;
			_BandNumsToColors[bandnum] = col;
		}
		//! return GDAL Color Interp
		GDALColorInterp GDALColor(int bandnum) {
			Colorcol = Color(bandnum);
			switch (col) {
				case Color::Red: return GCI_RedBand;
				case Color::Green: return GCI_GreenBand;
				case Color::Blue: return GCI_BlueBand;
				default: return GCI_GrayIndex;
			}
		}
		unsigned int Size() const { return _ColorsToBandNums.size(); }

		//! Get Bandnumber for given color (0 if no band)
		int Band(Color::Enum col) const {
			if (_ColorsToBandNums.find(col) != _ColorsToBandNums.end())
				return _ColorsToBandNums[col];
			else return 0;
		}
		//! Get Color for given band number
		Color::Enum Color(int col) const {
			if (_BandNumsToColors.find(col) != _BandNumsToColors.end())
				return _BandNumsToColors[col];
			else return Color::None;
		}
		//! Return Color Name for band number
		string ColorName(int col) const { return Name(Color(col)); }
		//! Return Color name for Color enum
		string ColorName(Color::Enum col) const { return Name(col); }
	private:
		mutable std::map<Color::Enum,int> _ColorsToBandNums;
		mutable std::map<int,Color::Enum> _BandNumsToColors;
		static string Name(Color::Enum col) {
			switch (col) {
				case Color::Blue: return "Blue";
				case Color::Green: return "Green";
				case Color::Red: return "Red";
				case Color::NIR: return "NIR";
				case Color::SWIR1: return "SWIR1";
				case Color::SWIR2: return "SWIR2";
				case Color::LWIR: return "LWIR";
				default: return "";
			}
			return "";
		}
	};

	// Utility functions
	//! Conversion function, any type to string
	template<typename T> inline string to_string(const T& t) {
		std::stringstream ss;
		ss << t;
		return ss.str();
	}

    //! Splits the string s on the given delimiter(s) and returns a list of tokens without the delimiter(s)
    /// <param name=s>The string being split</param>
    /// <param name=match>The delimiter(s) for splitting</param>
    /// <param name=removeEmpty>Removes empty tokens from the list</param>
    /// <param name=fullMatch>
    /// True if the whole match string is a match, false
    /// if any character in the match string is a match
    /// </param>
    /// <returns>A list of tokens</returns>
    inline std::vector<string> Split(const string& s, const string& match, bool removeEmpty=false, bool fullMatch=false) {
    	typedef string::size_type (string::*find_t)(const string& delim, string::size_type offset) const;
        std::vector<string> result;                 // return container for tokens
        string::size_type start = 0,           // starting position for searches
                          skip = 1;            // positions to skip after a match
        find_t pfind = &string::find_first_of; // search algorithm for matches

        if (fullMatch)
        {
            // use the whole match string as a key instead of individual characters skip might be 0. see search loop comments
            skip = match.length();
            pfind = &string::find;
        }

        while (start != string::npos)
        {
            // get a complete range [start..end)
            string::size_type end = (s.*pfind)(match, start);

            // null strings always match in string::find, but
            // a skip of 0 causes infinite loops. pretend that
            // no tokens were found and extract the whole string
            if (skip == 0) end = string::npos;

            string token = s.substr(start, end - start);
            if (!(removeEmpty && token.empty()))
            {
                // extract the token and add it to the result list
                result.push_back(token);
            }
            // start the next range
            if ((start = end) != string::npos) start += skip;
        }
        return result;
    }

    //! Parse string to array of ints
    inline std::vector<unsigned int> ParseToInts(const string& s) {
        std::vector<string> str = Split(s, " ,");
        std::vector<string>::const_iterator iv;
        std::vector<unsigned int> intarray;
        size_t loc;
        for (iv=str.begin();iv!=str.end();iv++) {
            loc = iv->find("-");
            if (loc==string::npos)
                intarray.push_back( atoi(iv->c_str()) );
            else {
                int b1 = atoi(iv->substr(0,loc).c_str());
                int b2 = atoi(iv->substr(loc+1).c_str());
                for (int i=b1;i<=b2;i++) intarray.push_back(i);
            }
        }
        return intarray;
    }
}

#endif
